#! /usr/bin/perl -w
#
# check_ifstatus.pl - nagios plugin 
# 
#
# Copyright (C) 2000 Christoph Kron
# Modified 5/2002 to conform to updated Nagios Plugin Guidelines (S. Ghosh)
#  Added -x option (4/2003)
#  Added -u option (4/2003)
#  Added -M option (10/2003)
#  Added SNMPv3 support (10/2003)
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#
#
# Report bugs to: ck@zet.net, nagiosplug-help@lists.sf.net
# 
# 11.01.2000 Version 1.0
#
# $Id: check_ifstatus.pl,v 1.9 2004/08/18 19:51:35 tonvoon Exp $

use POSIX;
use strict;
use lib "@PLUGINDIR@" ;
use utils qw($TIMEOUT %ERRORS &print_revision &support);

use Net::SNMP;
use Getopt::Long;
Getopt::Long::Configure('bundling');

my $PROGNAME = "check_sysuptime";

sub print_help ();
sub usage ();
sub process_arguments ();


my $status;
my $timeout ;
my $state = "UNKNOWN";
my $answer = "";
my $snmpkey=0;
my $snmpoid=0;
my $key=0;
my $community = "public";
my $maxmsgsize = 1472 ; # Net::SNMP default is 1472
my ($seclevel, $authproto, $secname, $authpass, $privpass, $auth, $priv, $context);
my $port = 161;
my $snmpSysUpTime = '.1.3.6.1.2.1.1.3.0';
my $hostname;
my $session;
my $error;
my $response;
my $snmp_version = 1;
my $opt_h ;
my $opt_V ;
my $threshold1 = 70000;
my $threshold2 = 30000;

# Just in case of problems, let's not hang Nagios
$SIG{'ALRM'} = sub {
     print ("ERROR: No snmp response from $hostname (alarm timeout)\n");
     exit $ERRORS{"UNKNOWN"};
};


#Option checking
$status = process_arguments();

if ($status != 0)
{
	print_help() ;
	exit $ERRORS{'OK'};
}


alarm($timeout);

if (!defined($response = $session->get_request($snmpSysUpTime))) {
	$answer=$session->error;
	$session->close;
	$state = 'CRITICAL';
	print ("$state: $answer $snmp_version\n");
	exit $ERRORS{$state};
}

$session->close;

alarm(0);

my $sysUpTime = &date2Time($response->{$snmpSysUpTime});
$answer = "sysUpTime($sysUpTime)";

if ($sysUpTime >= $threshold2) {
	$state = 'OK';
	$answer .= " >= $threshold2";
} elsif ($sysUpTime >= $threshold1) {
	$state = 'WARNING';
	$answer .= " < $threshold2";
} else {
	$state = 'CRITICAL';
	$answer .= " < $threshold1";
}

print $answer;
exit $ERRORS{$state};	

sub usage (){
	printf "\nMissing arguments!\n";
	printf "\n";
	printf "check_sysuptime -C <READCOMMUNITY> -p <PORT> -H <HOSTNAME>\n";
	printf "Copyright (C) 2007 Michot Marc\n";
	printf "\n\n";
	support();
	exit $ERRORS{"UNKNOWN"};
}

sub print_help (){
	printf "check_sysuptime plugin for Nagios monitors operational \n";
	printf "status of each network interface on the target host\n";
	printf "\nUsage:\n";
	printf "   -H (--hostname)   Hostname to query - (required)\n";
	printf "   -W (--warn)       Warn threshold in seconds\n";
	printf "   -T (--crit)       Critical threshold in seconds\n";
	printf "   -C (--community)  SNMP read community (defaults to public,\n";
	printf "                     used with SNMP v1 and v2c\n";
	printf "   -v (--snmp_version)  1 for SNMP v1 (default)\n";
	printf "                        2 for SNMP v2c\n";
	printf "                          SNMP v2c will use get_bulk for less overhead\n";
	printf "                        3 for SNMPv3 (requires -U option)";
	printf "   -p (--port)       SNMP port (default 161)\n";
	printf "   -L (--seclevel)   choice of \"noAuthNoPriv\", \"authNoPriv\", or	\"authPriv\"\n";
	printf "   -U (--secname)    username for SNMPv3 context\n";
	printf "   -c (--context)    SNMPv3 context name (default is empty	string)";
	printf "   -A (--authpass)   authentication password (cleartext ascii or localized key\n";
	printf "                     in hex with 0x prefix generated by using	\"snmpkey\" utility\n"; 
	printf "                     auth password and authEngineID\n";
	printf "   -a (--authproto)  Authentication protocol ( MD5 or SHA1)\n";
	printf "   -X (--privpass)   privacy password (cleartext ascii or localized key\n";
	printf "                     in hex with 0x prefix generated by using	\"snmpkey\" utility\n"; 
	printf "                     privacy password and authEngineID\n";
	printf "   -M (--maxmsgsize) Max message size - usefull only for v1 or v2c\n";
	printf "   -t (--timeout)    seconds before the plugin times out (default=$TIMEOUT)\n";
	printf "   -V (--version)    Plugin version\n";
	printf "   -h (--help)       usage help \n\n";
	print_revision($PROGNAME, '$Revision: 1.0 $');
	
}

sub process_arguments() {
	$status = GetOptions(
		"V"   => \$opt_V, "version"    => \$opt_V,
		"h"   => \$opt_h, "help"       => \$opt_h,
		"v=i" => \$snmp_version, "snmp_version=i"  => \$snmp_version,
		"W=i" => \$threshold1, "warn=i"  => \$threshold1,
		"T=i" => \$threshold2, "crit=i"  => \$threshold2,
		"C=s" => \$community,"community=s" => \$community,
		"L=s" => \$seclevel, "seclevel=s" => \$seclevel,
		"a=s" => \$authproto, "authproto=s" => \$authproto,
		"U=s" => \$secname,   "secname=s"   => \$secname,
		"A=s" => \$authpass,  "authpass=s"  => \$authpass,
		"X=s" => \$privpass,  "privpass=s"  => \$privpass,
		"c=s" => \$context,   "context=s"   => \$context,
		"p=i" =>\$port, "port=i" => \$port,
		"H=s" => \$hostname, "hostname=s" => \$hostname,
		"M=i" => \$maxmsgsize, "maxmsgsize=i" => \$maxmsgsize,
		"t=i" => \$timeout,    "timeout=i" => \$timeout,
		);
		
	if ($status == 0){
		print_help() ;
		exit $ERRORS{'OK'};
	}

	if ($threshold1 < $threshold2) {
		usage();
		exit $ERRORS{'OK'};
	}
	
	if ($opt_V) {
		print_revision($PROGNAME,'$Revision: 1.9 $ ');
		exit $ERRORS{'OK'};
	}

	if ($opt_h) {
		print_help();
		exit $ERRORS{'OK'};
	}

	unless (defined $timeout) {
		$timeout = $TIMEOUT;
	}

	if ($snmp_version =~ /3/ ) {
		# Must define a security level even though default is noAuthNoPriv
		# v3 requires a security username
		if (defined $seclevel  && defined $secname) {
		
			# Must define a security level even though defualt is noAuthNoPriv
			unless ($seclevel =~ /noAuthNoPriv|authNoPriv|authPriv/) {
				usage();
				exit $ERRORS{"UNKNOWN"};
			}
			
			# Authentication wanted
			if ($seclevel =~ /authNoPriv|authPriv/) {
		
				unless ($authproto =~ /MD5|SHA1/) {
					usage();
					exit $ERRORS{"UNKNOWN"};
				}

				if ( !defined $authpass) {
					usage();
					exit $ERRORS{"UNKNOWN"};
				}else{
					if ($authpass =~ /^0x/ ) {
						$auth = "-authkey => $authpass" ;
					}else{
						$auth = "-authpassword => $authpass";
					}
				}
					
			}
			
			# Privacy (DES encryption) wanted
			if ($seclevel eq  'authPriv' ) {
				if (! defined $privpass) {
					usage();
					exit $ERRORS{"UNKNOWN"};
				}else{
					if ($privpass =~ /^0x/){
						$priv = "-privkey => $privpass";
					}else{
						$priv = "-privpassword => $privpass";
					}
				}
			}

			# Context name defined or default

			unless ( defined $context) {
				$context = "";
			}
		
		
		
		}else {
					usage();
					exit $ERRORS{'UNKNOWN'}; ;
		}
	} # end snmpv3

	# for snmp v1 & v2c we default to community = "public"
	
	if (! utils::is_hostname($hostname)){
		usage();
		exit $ERRORS{"UNKNOWN"};
	}

	# create SNMP session handle based on options passed.

	if ( ! $snmp_version ) {
		$snmp_version =1 ;
	}else{
		if ( $snmp_version =~ /[12]/ ) {
	
			($session, $error) = Net::SNMP->session(
						-hostname  => $hostname,
						-community => $community,
						-port      => $port,
						-version	=> $snmp_version,
						-maxmsgsize => $maxmsgsize
			 );

		if (!defined($session)) {
					$state='UNKNOWN';
					$answer=$error;
					print ("$state: $answer");
					exit $ERRORS{$state};
		}

		
	}elsif ( $snmp_version =~ /3/ ) {

		if ($seclevel eq 'noAuthNoPriv') {
			($session, $error) = Net::SNMP->session(
				-hostname  => $hostname,
				-port      => $port,
				-version  => $snmp_version,
				-username => $secname,
			);

		}elsif ( $seclevel eq 'authNoPriv' ) {
			($session, $error) = Net::SNMP->session(
				-hostname  => $hostname,
				-port      => $port,
				-version  => $snmp_version,
				-username => $secname,
				-authprotocol => $authproto,
				-authpassword => $authpass
			);	
		}elsif ($seclevel eq 'authPriv' ) {
			($session, $error) = Net::SNMP->session(
				-hostname  => $hostname,
				-port      => $port,
				-version  => $snmp_version,
				-username => $secname,
				-authprotocol => $authproto,
				$auth,
				$priv
			);
		}
					
					
		if (!defined($session)) {
					$state='UNKNOWN';
					$answer=$error;
					print ("$state: $answer");
					exit $ERRORS{$state};
		}
			
	}else{
		$state='UNKNOWN';
		print ("$state: No support for SNMP v$snmp_version yet\n");
		exit $ERRORS{$state};
	}
}

return $ERRORS{"OK"};
				
}

sub date2Time {
	my $date = shift;

	if ($date =~ /^(\d+) days?, (\d+):(\d+):(\d+)\.(\d+)/) {
		return (((((($1 * 24) + $2) * 60) + $3) * 60) + $4);
	} elsif ($date =~ /^(\d+) hours?, (\d+):(\d+)\.(\d+)/) {
		return (((($1 * 60) + $2) * 60) + $3);
	} elsif ($date =~ /^(\d+) minutes?, (\d+)\.(\d+)/) {
		return ((($1 * 60) + $2) * 60);
	} elsif ($date =~ /^(\d+)\.(\d+) seconds?/) {
		return ($1);
	} else {
		return 0;
	}
}
